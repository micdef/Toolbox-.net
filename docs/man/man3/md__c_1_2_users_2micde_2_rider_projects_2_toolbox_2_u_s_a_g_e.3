.TH "md__c_1_2_users_2micde_2_rider_projects_2_toolbox_2_u_s_a_g_e" 3 "Version 1.0" "Toolbox" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md__c_1_2_users_2micde_2_rider_projects_2_toolbox_2_u_s_a_g_e \- Toolbox Usage Guide 
.PP


.PP
This guide provides detailed instructions for using the \fBToolbox\fP library\&.
.SH "Table of Contents"
.PP
.IP "1." 4
\fBGetting Started\fP
.IP "2." 4
\fBCryptography Services\fP
.IP "  \(bu" 4
\fBBase64 Encoding\fP
.IP "  \(bu" 4
\fBAES Encryption\fP
.IP "  \(bu" 4
\fBRSA Encryption\fP
.PP

.IP "3." 4
\fBFile Transfer Services\fP
.IP "  \(bu" 4
\fBFTP/FTPS\fP
.IP "  \(bu" 4
\fBSFTP\fP
.PP

.IP "4." 4
\fBMailing Services\fP
.IP "5." 4
\fBCreating Custom Services\fP
.IP "6." 4
\fBOpenTelemetry Integration\fP
.IP "7." 4
\fBConfiguration Options\fP
.IP "8." 4
\fBBest Practices\fP
.PP
.SH "Getting Started"
.PP
.SS "Basic Setup"
Add \fBToolbox\fP to your application:

.PP
.PP
.nf
using Toolbox\&.Core\&.Extensions;

var builder = Host\&.CreateApplicationBuilder(args);

// Register Toolbox core services
builder\&.Services\&.AddToolboxCore();

var app = builder\&.Build();
.fi
.PP
.SS "Configuration via appsettings\&.json"
.PP
.nf
{
  "Toolbox": {
    "EnableDetailedTelemetry": false,
    "ServicePrefix": "MyApp",
    "AsyncDisposalTimeout": "00:00:30"
  },
  "Toolbox:Telemetry": {
    "EnableTracing": true,
    "EnableMetrics": true,
    "EnableConsoleExport": false,
    "ServiceName": "MyApplication",
    "ServiceVersion": "1\&.0\&.0"
  }
}
.fi
.PP

.PP
.PP
.nf
builder\&.Services\&.AddToolboxCore(builder\&.Configuration);
builder\&.Services\&.AddToolboxOpenTelemetry(builder\&.Configuration);
.fi
.PP

.PP
.PP
.SH "Cryptography Services"
.PP
.SS "Base64 Encoding"
Base64 encoding/decoding service for text obfuscation (not encryption)\&.
.SS "Registration"
.PP
.nf
using Toolbox\&.Core\&.Extensions;
using Toolbox\&.Core\&.Options;

// Standard Base64
services\&.AddBase64Cryptography();

// URL\-safe Base64
services\&.AddBase64Cryptography(Base64EncodingTable\&.UrlSafe);

// With full options
services\&.AddBase64Cryptography(options =>
{
    options\&.EncodingTable = Base64EncodingTable\&.UrlSafe;
    options\&.IncludePadding = false;
});
.fi
.PP
.SS "Usage"
.PP
.nf
public class MyService
{
    private readonly ICryptographyService _crypto;

    public MyService(ICryptographyService crypto)
    {
        _crypto = crypto;
    }

    public async Task ProcessAsync()
    {
        // Encode
        var encoded = _crypto\&.Encrypt("Hello, World!");
        // Result: "SGVsbG8sIFdvcmxkIQ=="

        // Decode
        var decoded = _crypto\&.Decrypt(encoded);
        // Result: "Hello, World!"

        // Async versions
        var encodedAsync = await _crypto\&.EncryptAsync("Hello");
        var decodedAsync = await _crypto\&.DecryptAsync(encodedAsync);
    }
}
.fi
.PP

.PP
.PP
.SS "AES Encryption"
Secure symmetric encryption using AES (CBC mode with PKCS7 padding)\&.
.SS "Registration"
.PP
.nf
using Toolbox\&.Core\&.Extensions;
using Toolbox\&.Core\&.Options;

// Generate new key and IV
var (key, iv) = AesCryptographyService\&.GenerateKey(AesKeySize\&.Aes256);

// Register with generated key
services\&.AddAesCryptography(key, iv);

// Or with key size enum
services\&.AddAesCryptography(AesKeySize\&.Aes256);
.fi
.PP
.SS "Usage"
.PP
.nf
public class SecureService
{
    private readonly ICryptographyService _crypto;

    public SecureService(ICryptographyService crypto)
    {
        _crypto = crypto;
    }

    public async Task<string> EncryptDataAsync(string sensitiveData)
    {
        // Encrypt (returns Base64\-encoded ciphertext)
        var encrypted = await _crypto\&.EncryptAsync(sensitiveData);

        // Decrypt
        var decrypted = await _crypto\&.DecryptAsync(encrypted);

        return encrypted;
    }
}
.fi
.PP
.SS "Key Generation"
.PP
.nf
// Generate AES\-128 key
var (key128, iv128) = AesCryptographyService\&.GenerateKey(AesKeySize\&.Aes128);

// Generate AES\-192 key
var (key192, iv192) = AesCryptographyService\&.GenerateKey(AesKeySize\&.Aes192);

// Generate AES\-256 key (recommended)
var (key256, iv256) = AesCryptographyService\&.GenerateKey(AesKeySize\&.Aes256);
.fi
.PP

.PP
.PP
.SS "RSA Encryption"
Asymmetric encryption using RSA with various key sizes and padding modes\&.
.SS "Registration"
.PP
.nf
using Toolbox\&.Core\&.Extensions;
using Toolbox\&.Core\&.Options;

// Generate key pair
var keyPair = RsaCryptographyService\&.GenerateKeyPair(RsaKeySize\&.Rsa2048);

// Register with full key pair (encrypt + decrypt)
services\&.AddRsaCryptography(
    keyPair\&.PublicKey!,
    RsaPaddingMode\&.OaepSha256,
    keyPair\&.PrivateKey);

// Register with public key only (encrypt only)
services\&.AddRsaCryptography(
    keyPair\&.PublicKey!,
    RsaPaddingMode\&.OaepSha256);

// Register with X\&.509 certificate
var cert = new X509Certificate2("certificate\&.pfx", "password");
services\&.AddRsaCryptography(cert, RsaPaddingMode\&.OaepSha256);
.fi
.PP
.SS "Usage"
.PP
.nf
public class AsymmetricService
{
    private readonly ICryptographyService _crypto;

    public AsymmetricService(ICryptographyService crypto)
    {
        _crypto = crypto;
    }

    public async Task<(string encrypted, string decrypted)> ProcessAsync(string data)
    {
        // Encrypt with public key
        var encrypted = await _crypto\&.EncryptAsync(data);

        // Decrypt with private key (requires private key)
        var decrypted = await _crypto\&.DecryptAsync(encrypted);

        return (encrypted, decrypted);
    }
}
.fi
.PP
.SS "Key Generation"
.PP
.nf
// Generate key pair (bytes)
var keyPair = RsaCryptographyService\&.GenerateKeyPair(RsaKeySize\&.Rsa2048);
byte[] publicKey = keyPair\&.PublicKey!;
byte[] privateKey = keyPair\&.PrivateKey!;

// Generate self\-signed certificate
var certKeyPair = RsaCryptographyService\&.GenerateCertificate(
    RsaKeySize\&.Rsa4096,
    "CN=MyApplication",
    TimeSpan\&.FromDays(365));
X509Certificate2 certificate = certKeyPair\&.Certificate!;

// Public key only (for sharing)
var publicOnly = RsaCryptographyService\&.GenerateKeyPair(
    RsaKeySize\&.Rsa2048,
    includePrivateKey: false);
.fi
.PP
.SS "Padding Modes"
Mode  Description  \fRPkcs1\fP  PKCS#1 v1\&.5 padding (legacy)  \fROaepSha1\fP  OAEP with SHA-1  \fROaepSha256\fP  OAEP with SHA-256 (recommended)  \fROaepSha384\fP  OAEP with SHA-384  \fROaepSha512\fP  OAEP with SHA-512  

.PP
.PP
.SH "File Transfer Services"
.PP
.SS "FTP/FTPS"
File transfer service for FTP and FTPS (FTP over TLS) protocols\&.
.SS "Registration"
.PP
.nf
using Toolbox\&.Core\&.Extensions;
using Toolbox\&.Core\&.Options;

// Basic FTP
services\&.AddFtpFileTransfer(options =>
{
    options\&.Host = "ftp\&.example\&.com";
    options\&.Port = 21;
    options\&.Username = "user";
    options\&.Password = "password";
    options\&.Protocol = FileTransferProtocol\&.Ftp;
});

// Secure FTPS
services\&.AddFtpFileTransfer(options =>
{
    options\&.Host = "ftp\&.example\&.com";
    options\&.Port = 21;
    options\&.Username = "user";
    options\&.Password = "password";
    options\&.Protocol = FileTransferProtocol\&.Ftps;
});

// From configuration
services\&.AddFtpFileTransfer(configuration\&.GetSection("Ftp"));
.fi
.PP
.SS "Usage"
.PP
.nf
public class FileService
{
    private readonly IFileTransferService _ftp;

    public FileService(IFileTransferService ftp)
    {
        _ftp = ftp;
    }

    public async Task TransferFilesAsync()
    {
        // Upload single file
        await _ftp\&.UploadOneAsync(
            localPath: @"C:\\local\\file\&.txt",
            remotePath: "/remote/file\&.txt",
            overwrite: true);

        // Download single file
        await _ftp\&.DownloadOneAsync(
            remotePath: "/remote/file\&.txt",
            localPath: @"C:\\local\\downloaded\&.txt");

        // Batch upload
        var uploads = new[]
        {
            (@"C:\\local\\file1\&.txt", "/remote/file1\&.txt"),
            (@"C:\\local\\file2\&.txt", "/remote/file2\&.txt")
        };
        int successCount = await _ftp\&.UploadBatchAsync(uploads);

        // Batch download
        var downloads = new[]
        {
            ("/remote/file1\&.txt", @"C:\\local\\file1\&.txt"),
            ("/remote/file2\&.txt", @"C:\\local\\file2\&.txt")
        };
        int downloaded = await _ftp\&.DownloadBatchAsync(downloads);
    }
}
.fi
.PP

.PP
.PP
.SS "SFTP"
Secure file transfer over SSH (SFTP protocol)\&.
.SS "Registration"
.PP
.nf
using Toolbox\&.Core\&.Extensions;
using Toolbox\&.Core\&.Options;

// Password authentication
services\&.AddSftpFileTransfer(options =>
{
    options\&.Host = "sftp\&.example\&.com";
    options\&.Port = 22;
    options\&.Username = "user";
    options\&.Password = "password";
});

// Private key authentication
services\&.AddSftpFileTransfer(options =>
{
    options\&.Host = "sftp\&.example\&.com";
    options\&.Port = 22;
    options\&.Username = "user";
    options\&.PrivateKeyPath = @"C:\\keys\\id_rsa";
    options\&.PrivateKeyPassphrase = "passphrase"; // Optional
});

// Private key from string
services\&.AddSftpFileTransfer(options =>
{
    options\&.Host = "sftp\&.example\&.com";
    options\&.Username = "user";
    options\&.PrivateKeyContent = "\-\-\-\-\-BEGIN RSA PRIVATE KEY\-\-\-\-\-\\n\&.\&.\&.";
});
.fi
.PP
.SS "Usage"
.PP
.nf
public class SecureFileService
{
    private readonly IFileTransferService _sftp;

    public SecureFileService(IFileTransferService sftp)
    {
        _sftp = sftp;
    }

    public async Task TransferAsync(CancellationToken ct)
    {
        // Upload with cancellation support
        await _sftp\&.UploadOneAsync(
            @"C:\\data\\report\&.pdf",
            "/uploads/report\&.pdf",
            overwrite: true,
            ct);

        // Download
        await _sftp\&.DownloadOneAsync(
            "/downloads/data\&.csv",
            @"C:\\data\\data\&.csv",
            cancellationToken: ct);
    }
}
.fi
.PP
.SS "Configuration Options"
Option  Type  Default  Description  \fRHost\fP  string  -  Server hostname  \fRPort\fP  int  21/22  Server port  \fRUsername\fP  string  -  Login username  \fRPassword\fP  string?  null  Password (if using password auth)  \fRPrivateKeyPath\fP  string?  null  Path to private key file  \fRPrivateKeyContent\fP  string?  null  Private key as string  \fRPrivateKeyPassphrase\fP  string?  null  Private key passphrase  \fRProtocol\fP  FileTransferProtocol  Ftp  Ftp, Ftps, or Sftp  \fRConnectionTimeout\fP  TimeSpan  30s  Connection timeout  \fROperationTimeout\fP  TimeSpan  5min  Operation timeout  \fRBufferSize\fP  int  32KB  Transfer buffer size  \fRAutoCreateDirectory\fP  bool  true  Auto-create remote directories  

.PP
.PP
.SH "Mailing Services"
.PP
SMTP email sending service with TLS/SSL, OAuth2, and attachment support\&.
.SS "Registration"
.PP
.nf
using Toolbox\&.Core\&.Extensions;
using Toolbox\&.Core\&.Options;

// Generic SMTP
services\&.AddSmtpMailing(options =>
{
    options\&.Host = "smtp\&.example\&.com";
    options\&.Port = 587;
    options\&.SecurityMode = SmtpSecurityMode\&.StartTls;
    options\&.Username = "user@example\&.com";
    options\&.Password = "password";
    options\&.DefaultFrom = new EmailAddress("noreply@example\&.com", "My App");
});

// Gmail shortcut
services\&.AddGmailMailing(
    email: "myapp@gmail\&.com",
    appPassword: "xxxx\-xxxx\-xxxx\-xxxx");

// Outlook/Office 365 shortcut
services\&.AddOutlookMailing(
    email: "myapp@outlook\&.com",
    password: "password");

// Anonymous relay (internal servers)
services\&.AddSmtpMailing(options =>
{
    options\&.Host = "mail\&.internal\&.local";
    options\&.Port = 25;
    options\&.SecurityMode = SmtpSecurityMode\&.None;
});

// From configuration
services\&.AddSmtpMailing(configuration\&.GetSection("Mailing"));
.fi
.PP
.SS "Usage"
.PP
.nf
public class NotificationService
{
    private readonly IMailingService _mailing;

    public NotificationService(IMailingService mailing)
    {
        _mailing = mailing;
    }

    public async Task SendWelcomeEmailAsync(string userEmail, string userName)
    {
        var message = new EmailMessage
        {
            From = new EmailAddress("noreply@example\&.com", "My Application"),
            Subject = "Welcome to Our Service!",
            Body = $"<h1>Welcome, {userName}!</h1><p>Thank you for joining us\&.</p>",
            IsBodyHtml = true,
            To = { new EmailAddress(userEmail, userName) }
        };

        await _mailing\&.SendMailAsync(message);
    }

    public async Task SendReportAsync(string[] recipients, byte[] pdfReport)
    {
        var message = new EmailMessage
        {
            From = new EmailAddress("reports@example\&.com", "Report System"),
            Subject = "Monthly Report",
            Body = "Please find the monthly report attached\&.",
            IsBodyHtml = false,
            Attachments =
            {
                EmailAttachment\&.FromBytes(pdfReport, "report\&.pdf", "application/pdf")
            }
        };

        // Multiple recipients
        foreach (var recipient in recipients)
        {
            message\&.To\&.Add(recipient);
        }

        await _mailing\&.SendMailAsync(message);
    }

    public async Task SendBccEmailAsync(string[] bccRecipients)
    {
        // Email with BCC only (no visible recipients)
        var message = new EmailMessage
        {
            From = new EmailAddress("newsletter@example\&.com"),
            Subject = "Newsletter",
            Body = "<h1>Monthly Newsletter</h1>",
            IsBodyHtml = true
        };

        foreach (var bcc in bccRecipients)
        {
            message\&.Bcc\&.Add(bcc);
        }

        await _mailing\&.SendMailAsync(message);
    }
}
.fi
.PP
.SS "Email with Inline Images"
.PP
.nf
var logoBytes = File\&.ReadAllBytes("logo\&.png");

var message = new EmailMessage
{
    From = new EmailAddress("noreply@example\&.com"),
    Subject = "Email with Logo",
    Body = @"
        <html>
        <body>
            <img src='cid:company\-logo' alt='Logo' />
            <h1>Welcome!</h1>
        </body>
        </html>",
    IsBodyHtml = true,
    To = { "recipient@example\&.com" },
    Attachments =
    {
        EmailAttachment\&.CreateInline(logoBytes, "logo\&.png", "company\-logo")
    }
};

await _mailing\&.SendMailAsync(message);
.fi
.PP
.SS "Configuration Options"
Option  Type  Default  Description  \fRHost\fP  string  "localhost"  SMTP server hostname  \fRPort\fP  int  25  SMTP port (25, 587, 465)  \fRSecurityMode\fP  SmtpSecurityMode  Auto  Security mode  \fRUsername\fP  string?  null  SMTP username  \fRPassword\fP  string?  null  SMTP password  \fROAuth2AccessToken\fP  string?  null  OAuth2 token (Gmail, O365)  \fRConnectionTimeout\fP  TimeSpan  30s  Connection timeout  \fROperationTimeout\fP  TimeSpan  2min  Send timeout  \fRValidateCertificate\fP  bool  true  Validate SSL certificate  \fRDefaultFrom\fP  EmailAddress?  null  Default sender address  \fRDefaultReplyTo\fP  EmailAddress?  null  Default reply-to address  
.SS "Security Modes"
Mode  Port  Description  \fRAuto\fP  -  Automatic detection  \fRNone\fP  25  No encryption (internal only)  \fRStartTls\fP  587  Upgrade to TLS (recommended)  \fRStartTlsWhenAvailable\fP  587  TLS if available  \fRSslOnConnect\fP  465  Implicit SSL/TLS  

.PP
.PP
.SH "Creating Custom Services"
.PP
.SS "Synchronous Disposal"
For services with synchronous cleanup:

.PP
.PP
.nf
using Toolbox\&.Core\&.Base;

public class MyService : BaseDisposableService
{
    private readonly SomeResource _resource;

    public MyService(ILogger<MyService> logger)
        : base("MyService", logger)
    {
        _resource = new SomeResource();
    }

    public void DoWork()
    {
        ThrowIfDisposed();

        using var activity = StartActivity();
        var sw = Stopwatch\&.StartNew();

        _resource\&.Process();

        RecordOperation("DoWork", sw\&.ElapsedMilliseconds);
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            _resource?\&.Dispose();
        }
        base\&.Dispose(disposing);
    }
}
.fi
.PP
.SS "Asynchronous Disposal"
For services with async resources:

.PP
.PP
.nf
using Toolbox\&.Core\&.Base;

public class MyAsyncService : BaseAsyncDisposableService
{
    private readonly Stream _stream;

    public MyAsyncService(ILogger<MyAsyncService> logger)
        : base("MyAsyncService", logger)
    {
        _stream = new FileStream("data\&.bin", FileMode\&.OpenOrCreate);
    }

    public async Task ProcessAsync(CancellationToken ct = default)
    {
        ThrowIfDisposed();

        using var activity = StartActivity();
        var sw = Stopwatch\&.StartNew();

        await _stream\&.WriteAsync(data, ct);

        RecordOperation("ProcessAsync", sw\&.ElapsedMilliseconds);
    }

    protected override async ValueTask DisposeAsyncCore(CancellationToken ct)
    {
        await _stream\&.DisposeAsync();
    }
}
.fi
.PP

.PP
.PP
.SH "OpenTelemetry Integration"
.PP
.SS "Basic Tracing and Metrics"
.PP
.nf
builder\&.Services\&.AddToolboxOpenTelemetry(options =>
{
    options\&.EnableTracing = true;
    options\&.EnableMetrics = true;
    options\&.ServiceName = "MyApplication";
    options\&.ServiceVersion = "1\&.0\&.0";
});
.fi
.PP
.SS "OTLP Export"
.PP
.nf
builder\&.Services\&.AddToolboxOpenTelemetry(options =>
{
    options\&.OtlpEndpoint = "http://localhost:4317";
});
.fi
.PP
.SS "Custom Instrumentation"
.PP
.nf
using Toolbox\&.Core\&.Telemetry;

// Start a custom activity
using var activity = ToolboxActivitySource\&.StartActivity("CustomOperation");
activity?\&.SetTag("custom\&.tag", "value");

// Record metrics
ToolboxMeter\&.RecordOperation("MyService", "CustomOp", elapsedMs);
.fi
.PP
.SS "Available Metrics"
Metric  Type  Description  \fRtoolbox\&.operations\&.count\fP  Counter  Total operations  \fRtoolbox\&.operations\&.duration\fP  Histogram  Operation duration (ms)  \fRtoolbox\&.crypto\&.encrypt\&.count\fP  Counter  Encryption operations  \fRtoolbox\&.crypto\&.decrypt\&.count\fP  Counter  Decryption operations  \fRtoolbox\&.crypto\&.data\&.size\fP  Histogram  Data size (bytes)  \fRtoolbox\&.filetransfer\&.upload\&.count\fP  Counter  File uploads  \fRtoolbox\&.filetransfer\&.download\&.count\fP  Counter  File downloads  \fRtoolbox\&.filetransfer\&.size\fP  Histogram  File size (bytes)  

.PP
.PP
.SH "Configuration Options"
.PP
.SS "ToolboxOptions"
Option  Type  Default  Description  \fREnableDetailedTelemetry\fP  bool  false  Enable detailed telemetry  \fRServicePrefix\fP  string?  null  Prefix for service names  \fRAsyncDisposalTimeout\fP  TimeSpan  30s  Timeout for async disposal  
.SS "ToolboxTelemetryOptions"
Option  Type  Default  Description  \fREnableTracing\fP  bool  true  Enable distributed tracing  \fREnableMetrics\fP  bool  true  Enable metrics collection  \fREnableConsoleExport\fP  bool  false  Export to console  \fROtlpEndpoint\fP  string?  null  OTLP collector endpoint  \fRServiceName\fP  string  "Toolbox"  Service name for telemetry  \fRServiceVersion\fP  string  "1\&.0\&.0"  Service version  

.PP
.PP
.SH "Best Practices"
.PP
.SS "1\&. Always Check Disposal State"
.PP
.nf
public void DoWork()
{
    ThrowIfDisposed();  // Call this first
    // \&.\&.\&. rest of method
}
.fi
.PP
.SS "2\&. Use Activity Scopes for Tracing"
.PP
.nf
public async Task DoWorkAsync()
{
    using var activity = StartActivity();
    // Activity automatically ends when scope exits
}
.fi
.PP
.SS "3\&. Record Metrics for Performance"
.PP
.nf
var sw = Stopwatch\&.StartNew();
// \&.\&.\&. operation
RecordOperation("OperationName", sw\&.ElapsedMilliseconds);
.fi
.PP
.SS "4\&. Handle Cancellation in Async Operations"
.PP
.nf
public async Task ProcessAsync(CancellationToken ct = default)
{
    ct\&.ThrowIfCancellationRequested();
    await _service\&.DoWorkAsync(ct);
}
.fi
.PP
.SS "5\&. Use Appropriate Service Lifetimes"
.PP
.nf
// Singleton for stateless services
services\&.AddSingleton<ICryptographyService, AesCryptographyService>();

// Scoped for per\-request services
services\&.AddScoped<IFileTransferService, SftpFileTransferService>();

// Transient for lightweight services
services\&.AddTransient<IMailingService, SmtpMailingService>();
.fi
.PP
.SS "6\&. Secure Credential Management"
.PP
.nf
// Use configuration/secrets, not hardcoded values
services\&.AddSmtpMailing(configuration\&.GetSection("Mailing"));

// Or use Azure Key Vault, AWS Secrets Manager, etc\&.
var password = await secretsClient\&.GetSecretAsync("smtp\-password");
.fi
.PP
 
